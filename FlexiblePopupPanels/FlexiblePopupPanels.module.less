@import "../styles/skin.less";
@import "../styles/variables.less";

.flexiblePopupPanels {
	// Override for Popup
	&.popup {
		padding: @sand-flexiblepopuppanels-margin; // redirect this to padding for simpler size calculation
		margin: 0;
		max-height: 100vh;
		min-width: @sand-flexiblepopuppanels-min-width;
		box-sizing: border-box;
	}

	.viewport {
		position: relative;

		.panel {
			padding: @sand-flexiblepopuppanels-padding;
			// The next line is very long, but it calculates the maximum height by adding up all
			// of the paddings between this node and the edge of the screen, top and bottom.
			// If the margin or padding configuration changes, this will likely need to be updated.
			height: ~"calc(100vh -" ((extract(@sand-flexiblepopuppanels-margin, 1) * 2) + extract(@sand-flexiblepopuppanels-padding, 1) + extract(@sand-flexiblepopuppanels-padding, 1)) ~")";
		}
	}

	// this block is "tricks" the layout so the following .navButton rules position the before
	// button correctly in LTR and RTL locales
	.navCellBefore {
		direction: rtl;

		:global(.enact-locale-right-to-left) & {
			direction: ltr;
		}
	}

	.navCellAfter {
		/* identifies the "after" cell */
	}

	.navButton {
		position: absolute;
		transform: translate(0, -50%);
		margin: @sand-flexiblepopuppanels-navbutton-margin;
	}

	> .body {
		position: relative;
		pointer-events: none;
		padding: 0;
	}

	&.fullHeight {
		.bodyLayout {
			height: 100%;
		}
	}

	// Skin colors
	.applySkins({
		background-color: transparent;
	});
}

// Overrides for Panel
.panel {
	pointer-events: none;

	> .body {
		padding: 0;
	}

	.bodyLayout {
		// This `-webkit-fill-available` value is a bit funny. It only updates
		// after a "hard" layout recalculation, not all the time, so the content
		// dimensions could change, but it won't update until something triggers
		// it, like a height, width, or some other related prop also changes.
		// This value, however, does do exactly what we need. Fill up to a point
		// and not expand beyond that.
		max-height: -webkit-fill-available; // Expand to the bounds, then stop.
		pointer-events: auto;
	}

	// Target class-less Header container to capture pointer events that fall into the margin of header, outside its DOM box.
	> *:first-child {
		pointer-events: auto;
	}

	.header {
		&.showBack {
			margin-left: @sand-flexiblepopuppanels-header-padding;
		}
	}

	.content {
		margin: @sand-flexiblepopuppanels-panel-margin;
		padding: @sand-flexiblepopuppanels-panel-padding;
	}

	:global(.enact-locale-right-to-left) & {
		// force the body to LTR maintain left alignment of panel contents
		> .body {
			direction: ltr;

			// but reset direction for content
			.bodyLayout {
				direction: rtl;
			}
		}
	}

	.applySkins({
		.header {
			filter: drop-shadow(@sand-flexiblepopuppanels-header-shadow);
		}

		.content {
			background-color: @sand-flexiblepopuppanels-panel-bg-color;
			border-radius: @sand-flexiblepopuppanels-panel-border-radius;
			filter: drop-shadow(@sand-flexiblepopuppanels-panel-shadow);
		}
	});
}
